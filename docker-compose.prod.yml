x-restart_policy: &restart_policy
  restart: unless-stopped

x-logging: &logging
  logging:
    driver: 'local'
    options:
      max-size: '10m'
      max-file: '5'

x-network: &network
  networks:
    - docker-net

x-depends-database: &depends-database
  dripdrop-postgres:
    condition: service_healthy

x-depends-redis: &depends-redis
  dripdrop-redis:
    condition: service_healthy

x-depends-all: &depends-all
  depends_on:
    <<:
      - *depends-database
      - *depends-redis

version: '3'
services:
  dripdrop-server:
    image: dripdrop/image
    container_name: dripdrop-server
    command: [ "./scripts/server.sh" ]
    healthcheck:
      test:
        [
          "CMD",
          "curl",
          "-f",
          "http://localhost:5000/healthcheck"
        ]
      interval: 30s
    environment:
      ENV: ${ENV}
    <<:
      - *depends-all
      - *logging
      - *restart_policy
      - *network

  dripdrop-worker:
    image: dripdrop/image
    command: [ "./scripts/worker.sh" ]
    environment:
      ENV: ${ENV}
      REDIS_URL: ${REDIS_URL}
    <<:
      - *depends-all
      - *logging
      - *restart_policy
      - *network

  dripdrop-postgres:
    image: postgres:14
    container_name: dripdrop-postgres
    healthcheck:
      test: [ "CMD", "pg_isready", "-U", "${DATABASE}" ]
      interval: 30s
    environment:
      POSTGRES_USER: ${DATABASE_USER}
      POSTGRES_PASSWORD: ${DATABASE_PASSWORD}
      POSTGRES_DB: ${DATABASE}
      POSTGRES_HOST_AUTH_METHOD: md5
    volumes:
      - type: volume
        source: postgres_volume
        target: /var/lib/postgresql/data
    <<:
      - *logging
      - *restart_policy
      - *network

  dripdrop-redis:
    image: redis
    container_name: dripdrop-redis
    healthcheck:
      test: [ "CMD", "redis-cli", "ping" ]
      interval: 30s
    volumes:
      - type: volume
        source: redis_volume
        target: /data
    <<:
      - *logging
      - *restart_policy
      - *network

networks:
  docker-net:
    external: true

volumes:
  postgres_volume: {}
  redis_volume: {}
  temp_volume: {}
